import jenkins.model.*
import hudson.model.*
import hudson.model.ParametersDefinitionProperty

import hudson.model.StringParameterDefinition
import hudson.model.BooleanParameterDefinition
import hudson.model.ChoiceParameterDefinition
import hudson.model.TextParameterDefinition
import hudson.model.PasswordParameterDefinition
import hudson.model.FileParameterDefinition

// =====================
// CONFIG - chỉnh ở đây
// =====================
def JOB_REGEX   = /.*?/          // ví dụ: /.*standalone.*/ hoặc /folderA\/.*/ (match fullName)
def DRY_RUN     = true           // true = chỉ log, không save
def ACTION      = "ADD_ONLY"     // "ADD_ONLY" | "UPSERT"

// Parameter config
def PARAM_TYPE  = "choice"       // string | boolean | choice | text | password | file
def PARAM_NAME  = "ENV"
def PARAM_DESC  = "Managed by groovy script"

// default/value per type:
def STRING_DEFAULT  = "SIT"
def BOOL_DEFAULT    = true
def TEXT_DEFAULT    = "line1\nline2"
def PASSWORD_DEFAULT_PLAIN = "secret"   // lưu dạng Secret bên trong Jenkins
def CHOICES_LIST    = ["SIT","UAT","PROD"]
// FILE: không có default, Jenkins sẽ nhận file khi build

// =====================
// Helpers
// =====================
def buildParamDef(String type) {
  switch (type.toLowerCase()) {
    case "string":
      return new StringParameterDefinition(PARAM_NAME, STRING_DEFAULT, PARAM_DESC)

    case "boolean":
      return new BooleanParameterDefinition(PARAM_NAME, BOOL_DEFAULT, PARAM_DESC)

    case "choice":
      // ChoiceParameterDefinition nhận chuỗi choices dạng "a\nb\nc"
      return new ChoiceParameterDefinition(PARAM_NAME, CHOICES_LIST.join("\n"), PARAM_DESC)

    case "text":
      return new TextParameterDefinition(PARAM_NAME, TEXT_DEFAULT, PARAM_DESC)

    case "password":
      return new PasswordParameterDefinition(PARAM_NAME, PASSWORD_DEFAULT_PLAIN, PARAM_DESC)

    case "file":
      return new FileParameterDefinition(PARAM_NAME, PARAM_DESC)

    default:
      throw new IllegalArgumentException("Unsupported PARAM_TYPE: ${type}")
  }
}

def isJobBuildable(Job j) {
  // bỏ qua các loại job không nên sửa / không build được nếu cần
  return true
}

// =====================
// Main
// =====================
def jenkins = Jenkins.get()
def jobs = jenkins.getAllItems(Job.class).findAll { it.fullName ==~ JOB_REGEX && isJobBuildable(it) }

println("Matched jobs: ${jobs.size()} by regex: ${JOB_REGEX}")
println("DRY_RUN=${DRY_RUN}, ACTION=${ACTION}, TYPE=${PARAM_TYPE}, NAME=${PARAM_NAME}")

def newDef = buildParamDef(PARAM_TYPE)

int touched = 0
int skipped = 0
int failed  = 0

jobs.each { job ->
  try {
    def prop = job.getProperty(ParametersDefinitionProperty)
    def defs = prop?.parameterDefinitions ? new ArrayList<>(prop.parameterDefinitions) : new ArrayList<>()

    def idx = defs.findIndexOf { it.name == PARAM_NAME }

    if (idx >= 0 && ACTION == "ADD_ONLY") {
      println("[SKIP] ${job.fullName} already has param '${PARAM_NAME}'")
      skipped++
      return
    }

    if (idx >= 0 && ACTION == "UPSERT") {
      defs.set(idx, newDef)
      println("[UPD ] ${job.fullName} replace param '${PARAM_NAME}' (${prop.parameterDefinitions[idx].class.simpleName} -> ${newDef.class.simpleName})")
    } else if (idx < 0) {
      defs.add(newDef)
      println("[ADD ] ${job.fullName} add param '${PARAM_NAME}' (${newDef.class.simpleName})")
    }

    if (!DRY_RUN) {
      job.removeProperty(ParametersDefinitionProperty)
      job.addProperty(new ParametersDefinitionProperty(defs))
      job.save()
    }

    touched++
  } catch (e) {
    println("[FAIL] ${job.fullName} - ${e.class.simpleName}: ${e.message}")
    failed++
  }
}

println("DONE. touched=${touched}, skipped=${skipped}, failed=${failed}, dryRun=${DRY_RUN}")
